<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>Simplex, by Conor O'Brien</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Simplex</h1>
        <h2>An Esoteric Coding Language by <em>Conor O'Brien</em></h2>

        <section id="downloads">
          <a href="https://github.com/ConorOBrien-Foxx/Simplex/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/ConorOBrien-Foxx/Simplex/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/ConorOBrien-Foxx/Simplex" class="btn btn-github"><span class="icon"></span>View on GitHub</a><p style="font-size: 10px;">Note that if you are downloading the interpreter, it may be out of date, not supporting many of the newer additions, also containing outdated commands. You may find some, erm, <em>interesting</em> commands in there; this is because Simplex orginally was intended as a joke language. The more you know!</p>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h1>
<a id="simplex" class="anchor" href="#simplex" aria-hidden="true"><span class="octicon octicon-link"></span></a>Simplex</h1>

<p><strong>Simplex</strong> is a golf-based (i.e. esoteric) programming language that is in its developing stages. It is driven to be somewhat effective at a majority of golfing challenges while retaining its intuitive nature.</p>

<h1>
<a id="features" class="anchor" href="#features" aria-hidden="true"><span class="octicon octicon-link"></span></a>Features</h1>

<h2>
<a id="strip-tape-based-language" class="anchor" href="#strip-tape-based-language" aria-hidden="true"><span class="octicon octicon-link"></span></a>Strip-/Tape-Based Language</h2>

<p>Simplex features a right-open memory tape (the term “strip” is also used synonymously), and can be compared to Brain**** in that it allows you to traverse this memory tape. The commands to traverse left and right are <code>L</code> and <code>R</code>, respectively. Traversing to a negative position isn't disallowed, but may/will result in buggy behaviour with other commands.</p>

<p>(Also, as an aside, I will use an acronym to shorten what I am saying. When I say &ldquo;IUF&rdquo;, I mean &ldquo;In the Usual Fashion&rdquo;; this fashion is described as thus: for an <i>n</i>-ary command <i>C</i>, the function is executed using the current cell as the first argument, then the previous cell as the second argument, etc. The value of this function with its arguments is then set to the place of which the last argument was contained; all other cells in which other arguments resided in (except the register) are set to zero.</p>

<p>Furthermore, when I use the notation (typeN,&hellip;,type1), I am saying that the first argument is of type1, the second of type2, &hellip;, the Nth of typeN. For example, a function that accepts (tuple,any) would require the current cell to be any type and the previous cell to be a tuple. Similarly, (int,tuple) would require the current byte to be a tuple and the previous byte to be an integer.)</p>

<h2>
<a id="pre--and-regular-processed-commands" class="anchor" href="#pre--and-regular-processed-commands" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pre- and regular-processed commands.</h2>

<p>Simplex features two parsing phases: a pre-proccessing phase and a regular processing phase. In the pre-processing phase, there are two main things going on, besides internal preinitalizations:</p>

<ol>
<li>Single-line comments are removed. That is,  <code>s/(.+?)~~.+$/$1/g</code>. </li>
<li>Compression fields are removed. A compression field is something of the form <code>(.+)(\d+)</code>, that is, (stuff)N, where N is a number. It simply repeats the expression N times. Currently, only linear i.e. non-stacked compression fields are supported. An example would be <code>(RR)5 =&gt; RRRRRRRRRR</code>.</li>
</ol>

<p>All other commands (including inline comments <code>!...!</code>) are proccessed during parsing.</p>

<h1>
<a id="commands" class="anchor" href="#commands" aria-hidden="true"><span class="octicon octicon-link"></span></a>Commands</h1>
<h2><a id="commands" class="anchor" href="#vpsevenchanges" aria-hidden="true"><span class="octicon octicon-link"></span></a>v.0.7</h2>
<h3>What's changed</h3>
(note that the fold (<code>Z</code>) and map (<code>m</code>) commands create their own temporary strips)
<ol>
  <li><code>C</code> command now supports the obtaining of characters using <code>%N</code> within the SiRegex</li>
<li>Moved <code>r</code> command into mathrelations; <code>r</code> now does the following: The register holds a position, the byte a character. Replaces the register's value-d command in the code with the current byte as a character
</li>
<li>Moved <code>q</code> command into mathrelations; <code>q</code> now does the following: (num) sets the previous byte to the minimum of the current byte and the previous byte, sets the previous byte to zero<br>(tuple) returns the min element of that tuple
</li>
<li>Added <code>:</code> - Removes the last character from the outer program or, if there is a number following, removes the nth to last character from the outer program</li>
<li>Added mathrelations command <code>^</code>. It is followed by a character, which executes a command. Here are the commands that can be executed with it:
<table>
  <tr><td>A</td><td>sine of current byte</td></tr>
  <tr><td>B</td><td>tangent of current byte</td></tr>
  <tr><td>C</td><td>cosine of current byte</td></tr>
  <tr><td>D</td><td>sets current byte to <code>10^currentbyte</code></td></tr>
  <tr><td>E</td><td>sets current byte to <code>e^currentbyte</code></td></tr>
  <tr><td>F</td><td>sets previous byte to the LCM of this byte and the previous byte, setting this byte to zero</td></tr>
  <tr><td>G</td><td>converts current byte to radians</td></tr>
  <tr><td>H</td><td>sets previous byte to the GCD of this byte and the previous byte, setting this byte to zero</td></tr>
  <tr><td>I</td><td>calculates standard deviation of current tuple/strip and sets the last byte in the tuple/strip to it</td></tr>
  <tr><td>J</td><td>calculates population deviation of current tuple/strip and sets the last byte in the tuple/strip to it</td></tr>
  <tr><td>K</td><td>calculates mean of tuple/strip and sets it to the last byte</td></tr>
  <tr><td>L</td><td>calculates median of tuple/strip and sets it to the last byte</td></tr>
  <tr><td>M</td><td>sets current byte to absolute value of current byte</td></tr>
  <tr><td>N</td><td>sets current byte to the sign of current byte</td></tr>
  <tr><td>O</td><td>squares current byte</td></tr>
  <tr><td>P</td><td>sets current byte to &Phi; = 1 - &phi; = (1-sqrt[5])/2</td></tr>
  <tr><td>Q</td><td>tuple membership; if current byte is in the tuple held in the previous cell, sets the current byte to 1; otherwise, 0</td></tr>
  <tr><td>R</td><td>(tuple, tuple): takes intersection of two tuples IUF<br>(num, num): takes the logical conjuction of the two cells IUF</td></tr>
  <tr><td>S</td><td>(tuple, tuple): takes union of two tuples IUF<br>(num, num): takes the logical disjunction of the two cells IUF</td></tr>
  <tr><td>T</td><td>(int): Sets the current byte to the (int)th triangular number (i.e. n(n+1)/2 = (n<sup>2</sup>+n)/2)</td></tr>
  <tr><td>U</td><td>(/): sets the current byte to the empty/null set/tuple (&varnothing;)</td></tr>
  <tr><td>V</td><td>(tuple, tuple): calculates set difference IUF<br>(num, num): Logically xor two bytes IUF</td></tr>
  <tr><td>W</td><td>(tuple): sets current byte to permutation of tuple<br>(num): sets current byte to its factorial</td></tr>
  <tr><td>X</td><td>(tuple): sum of tuple<br>(strip): sum of strip</td></tr>
  <tr><td>Y</td><td>(tuple): product of tuple<br>(strip): sum of strip</td></tr>
  <tr><td>Z</td><td>is the fold/reduce command performed on a tuple; implicit <code>[</code> follows <code>Z</code></td> Executes inner code. Within the code block constructed, one can use <code>^_</code> to access the current value, <code>^,</code> to access the previous value, and <code>^~</code> is the tuple.</tr>
  <tr><td>a</td><td>arcsin of current byte</td></tr>
  <tr><td>b</td><td>arctan of current byte</td></tr>
  <tr><td>c</td><td>arccos of current byte</td></tr>
  <tr><td>d</td><td>log<sub>10</sub> of current byte</td></tr>
  <tr><td>e</td><td>ln of current byte</td></tr>
  <tr><td>f</td><td>atan2 in the usual fashion (atan2(previous byte,current byte))</td></tr>
  <tr><td>g</td><td>converts to degrees</td></tr>
  <tr><td>h</td><td>sets alphabet ([A-Za-z]) as a tuple</td></tr>
  <tr><td>i</td><td>sets digits ([0-9]) as a tuple</td></tr>
  <tr><td>j</td><td>sets alphabet ([A-Z]) as a tuple</td></tr>
  <tr><td>k</td><td>sets digalphabet ([A-Za-z0-9]) as a tuple</td></tr>
  <tr><td>l</td><td>sets alphabet ([a-z]) as a tuple</td></tr>
  <tr><td>m</td><td>followed by an implicit [. Same rules as fold for accessing index and member. Use ^N to indicate which index to "return", N a number</td></tr>
  <tr><td>n</td><td>same as J, except with min.</td></tr>
  <tr><td>o</td><td>converts the strip to an equivalent tuple</td></tr>
  <tr><td>p</td><td>Prints &phi; (golden ratio)</td></tr>
  <tr><td>q</td><td>"Currently unassigned"</td></tr>
  <tr><td>r</td><td>reverses the current number, removing leading zeroes. (1000 &rarr; 1; 2340&rarr; 432; 1234 &rarr; 4321)</td></tr>
  <tr><td>s-z</td><td>"Currently unassigned"</td></tr>
  <tr><td>[</td><td>Puts a <code>^</code> in front of each of the inner, up to the matching <code>]</code></td></tr>
</table></li></ol>
<h2><a id="commands" class="anchor" href="#vpsixchanges" aria-hidden="true"><span class="octicon octicon-link"></span></a>v.0.6</h2>
<h3>What's changed</h3>
<ol>
  <li>Removed the <code>-</code> command</li>
  <li><code>@</code> now writes the cell to the register</li>
  <li><code>&</code> now writes the value in the register to the cell</li>
  <li>Added <code>_</code> command, which sets the cell to the square root of itself (equivalent to the command sequence <code>j1UERp</code>)</li>
  <li><code>F</code> command now does not delete current byte</li>
  <li><code>C</code> is now automatically followed by an implicit <code>/</code></li>
</ol>
<h2><a id="commands" class="anchor" href="#vpfive" aria-hidden="true"><span class="octicon octicon-link"></span></a>v.0.5</h2>
<table><tr><td>A</td><td>Adds the current byte to the previous byte and removes the current byte, decrements pointer</td></tr>
<tr><td>B</td><td>Converts the byte to binary</td></tr>
<tr><td>C</td><td>Takes the following regex and matches it with the strip, treating each value as a character in a string (see "regex form" below)</td></tr>
<tr><td>D</td><td>Sets the current byte to twice its value</td></tr>
<tr><td>E</td><td>Raises the previous byte the (current byte)th power and removes the current byte, decrements pointer</td></tr>
<tr><td>F</td><td>Goes back <i>n</i> characters in the source code, where n is the current byte. Deletes the current byte.</td></tr>
<tr><td>G</td><td>Asks for single-char input and Manhattan-adds it to the current byte</td></tr>
<tr><td>H</td><td>Sorts the current strip by numeric value; resets the pointer</td></tr>
<tr><td>I</td><td>Increments the byte</td></tr>
<tr><td>J</td><td>Sets the previous byte to the maximum of the current byte and the previous byte, sets the previous byte to zero OR if there is a tuple at the current byte, returns the max element of that tuple.
</td></tr>
<tr><td>K</td><td>Splits the current number up into digits, inside a tuple.
</td></tr>
<tr><td>L</td><td>Goes left a byte</td></tr>
<tr><td>M</td><td>Decrements the byte</td></tr>
<tr><td>N</td><td>Toggles newline mode. Default is true. If true, every numeric output is followed by a newline. Else, nothing follows each number. (Trailing Newlines)</td></tr>
<tr><td>O</td><td>Goes to the (current byte)th position in the source code</td></tr>
<tr><td>P</td><td>Manhattan adds pi = 3.141592653589793… to the stack</td></tr>
<tr><td>Q</td><td>Adds program source code to outer program, from the beginning (exclusive of ! characters, if the current byte is not zero) If byte is 2, duplicates current command</td></tr>
<tr><td>R</td><td>Goes right a byte</td></tr>
<tr><td>S</td><td>Subtracts the current byte from the previous byte and removes the current byte, decrements pointer</td></tr>
<tr><td>T</td><td>Multiplies the previous byte by the current byte and removes the current byte, decrements pointer</td></tr>
<tr><td>U</td><td>Sets the current byte to half its value</td></tr>
<tr><td>V</td><td>Divides the previous byte by the current byte and removes the current byte, decrements pointer</td></tr>
<tr><td>W</td><td>Converts number/character to a generic base, held in the register
</td></tr>
<tr><td>X</td><td>Sets the current byte to a random integer from 0 to the current byte</td></tr>
<tr><td>Y</td><td>Floors the current value</td></tr>
<tr><td>Z</td><td>Converts current number from a base held in the register to base 10
</td></tr>
<tr><td>a</td><td>Make the number negative</td></tr>
<tr><td>b</td><td>Asks for input that will store each character into a byte on the strip in order.</td></tr>
<tr><td>c</td><td>Copies the current byte to the next byte and increments the pointer.</td></tr>
<tr><td>d</td><td>Reverses the entire strip/tuple (tuple check first)</td></tr>
<tr><td>e</td><td>Manhattan adds e = 2.718281828459045… to the stack.</td></tr>
<tr><td>f</td><td>Turns off safety mode.</td></tr>
<tr><td>g</td><td>Clears the strip and outputs it as ASCII characters, or, if tuple: deletes the tuple and output its characters as ASCII.</td></tr>
<tr><td>h</td><td>Defines a macro Q for the following instruction/code block; Q starts at 0; after every call of h, Q increments. When followed by a number, activates call func: hQ. There is an implicit [ after the h, so a closing ] is required.</td></tr>
<tr><td>i</td><td>Asks for input as a number and stores it.</td></tr>
<tr><td>j</td><td>Inserts a new cell at the pointer, pushing everything right.</td></tr>
<tr><td>k</td><td>Skips the next command/command block</td></tr>
<tr><td>l</td><td>Writes the number of non-empty cells in the strip to the current cell</td></tr>
<tr><td>m</td><td>Writes the index of the pointer to the cell</td></tr>
<tr><td>n</td><td>Logically negates the current byte</td></tr>
<tr><td>o</td><td>Outputs the current byte as a number (toggles)</td></tr>
<tr><td>p</td><td>Removes cell at the pointer, pulling everything to the right leftwards; moves pointer leftwards</td></tr>

<tr><td>q</td><td>Checks for membership in a tuple (tupleByte member &lt;=> member IN tupleByte), like this: (t1,…,tN) M → (q) → (t1,…,tN) C; C is whether (1) or not (0) M in (t1,…,tN).</td></tr>
<tr><td>r</td><td>Reverses the current number (byte), removing leading zeroes. (1000→1;2340→432;1234→4321) </td></tr>
<tr><td>s</td><td>Outputs the current byte as a string character</td></tr>
<tr><td>t</td><td>Applies the next character's function (supports […]) to every member of the current strip</td></tr>
<tr><td>u</td><td>Increments the strip number ("goes up")</td></tr>
<tr><td>v</td><td>Decrements the strip number ("goes down")</td></tr>
<tr><td>w</td><td>Applies the next function(s) backwards</td></tr>
<tr><td>x</td><td>A confirmation message; if "ok", 1 is stored to the current byte; 0 otherwise.</td></tr>
<tr><td>y</td><td>Takes the current byte n and takes the n previous entries and pushes it into a tuple, then storing the tuple in the byte n bytes away OR if the current byte is a tuple, expands the tuple into n bytes (inclusive of the current byte, going out.)</td></tr>
<tr><td>z</td><td>Resets the byte to zero</td></tr>
<tr><td>0-9</td><td>Manhattan adds the number to the byte</td></tr>
<tr><td>?</td><td>Skips the next command (block) if the byte is zero.</td></tr>
<tr><td>[…]</td><td>Block statement. Read by ? as "one character".</td></tr>
<tr><td>{…}</td><td>While loop. Execution continues until the current byte is zero.</td></tr>
<tr><td>!…!</td><td>Comments!</td></tr>
<tr><td>@</td><td>Copies the current byte to the register OR if there is a value in the register, empties the register onto the current byte</td></tr>
<tr><td>-</td><td>Dumps the value of the register into the void</td></tr>
<tr><td>&</td><td>Equivalent to @@</td></tr>
<tr><td>#</td><td>Stops evaluation</td></tr>
<tr><td>;</td><td>Pushes the current character to the outer program (ability to compile to itself); if there are characters on the outer program at the end of execution, evaluates the outer program as the inner program.</td></tr>
<tr><td>`</td><td>This command's effect varies, being dependant on the number of instances in the program of it: (1 instances) Suppresses evaluation of outer program. (2 instances) and instead outputs it. (3 instances) Evaluates outer program, copying the current program to the next outer program.</td></tr>
<tr><td>~</td><td>Switches the current value with the previous value</td></tr>
<tr><td>*</td><td>Copy to the next cell, pushing cells right</td></tr>
<tr><td>=</td><td>N = current index. S = strip. S[N] = S[N] == S[N-1] (Equality testing)</td></tr>
<tr><td>></td><td>N = current index. S = strip. S[N] = S[N] > S[N-1] (Inequality testing)</td></tr>
<tr><td>&lt;</td><td>N = current index. S = strip. S[N] = S[N] &lt; S[N-1] (Inequality testing)</td></tr>
<tr><td>"</td><td>Toggle string-parsing mode. In string-parsing mode, char codes are written to the current byte and the pointer incremented. E.g., "Alive" would write values 65, 108, 105, 118, 101 to the current byte, the byte after that, etc.</td></tr>
<tr><td>'</td><td>Sets the current byte to the next char code.</td></tr>
<tr><td>(…)n</td><td>Repeats … n times (pre-code compilation). If left off, assumed to be repeated once.</td></tr>
</table>
<h1>
<a id="commands" class="anchor" href="#commands" aria-hidden="true"><span class="octicon octicon-link"></span></a>Regex Form</h1>
<p>There are three parts to a Simplex Regex: the query section, the tag section, and the replacement section, in that order. A Simplex Regex (hereafter called a &ldquo;SiRegex&rdquo;) might look like this: <code>/query/tags/repl/</code>. The following tags are available:<ol><li><code>g</code> - global match (if omitted, will only match the current cell)</li><li><code>i</code> - ignore case</li><li><code>t</code> - will put the matched selections in tuples joined by <code>repl</code>; said <code>repl</code> will be placed between each tuple.</li><li></li></ol> Within a SiRegex, one can use the following notations to refer to the strip, etc.: <ol><li><code>&x</code> is the value of the <code>x</code>th byte</li></ol></p>
      </section>
    </div>

    
  </body>
</html>
